<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šç»´è½¨é“åŠ¨æ€æ¨¡æ‹Ÿå™¨ - Nä½“ç³»ç»Ÿ</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body, #root { width: 100%; height: 100%; overflow: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }
        input[type="range"] {
            -webkit-appearance: none;
            background: #374151;
            border-radius: 8px;
            height: 6px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #06b6d4;
            border-radius: 50%;
            cursor: pointer;
        }
        .param-input {
            width: 60px;
            background: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 4px;
            padding: 2px 4px;
            color: #22d3ee;
            font-family: monospace;
            font-size: 12px;
            text-align: right;
        }
        .param-input:focus {
            outline: none;
            border-color: #06b6d4;
        }
        .panel {
            background: rgba(17, 24, 39, 0.95);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(75, 85, 99, 0.5);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }
        .panel-header {
            cursor: pointer;
            user-select: none;
            padding: 10px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(75, 85, 99, 0.3);
        }
        .panel-header:hover {
            background: rgba(55, 65, 81, 0.5);
        }
        .panel-content {
            padding: 12px 14px;
            max-height: 70vh;
            overflow-y: auto;
        }
        .panel-content::-webkit-scrollbar {
            width: 4px;
        }
        .panel-content::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 2px;
        }
        .collapsed .panel-content {
            display: none;
        }
        .collapsed .panel-header {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const PLANET_COLORS = [
          '#44ff88', '#ff6b6b', '#4ecdc4', '#ffe66d', 
          '#ff8cc8', '#a855f7', '#fb923c', '#38bdf8',
        ];

        // å¯æŠ˜å é¢æ¿ç»„ä»¶
        const Panel = ({ title, icon, children, defaultOpen = true, className = '' }) => {
          const [isOpen, setIsOpen] = useState(defaultOpen);
          return (
            <div className={`panel ${isOpen ? '' : 'collapsed'} ${className}`}>
              <div className="panel-header" onClick={() => setIsOpen(!isOpen)}>
                <span className="text-sm font-semibold flex items-center gap-2">
                  {icon && <span>{icon}</span>}
                  {title}
                </span>
                <span className="text-gray-400 text-xs">{isOpen ? 'â–¼' : 'â–¶'}</span>
              </div>
              <div className="panel-content">
                {children}
              </div>
            </div>
          );
        };

        const OrbitalSimulator4D = () => {
          // ç‰©ç†å‚æ•°
          const [lambda, setLambda] = useState(-0.01);
          const [sunMass, setSunMass] = useState(1.0);
          const [planetMass, setPlanetMass] = useState(0.1);
          const [softening, setSoftening] = useState(0.2);
          const [gravityPower, setGravityPower] = useState(3);
          const [damping, setDamping] = useState(0); // æ˜Ÿé™…æ°”ä½“é˜»å°¼ç³»æ•°
          const [sunSpin, setSunSpin] = useState(0); // æ’æ˜Ÿè‡ªè½¬è§’é€Ÿåº¦
          const [spinDrag, setSpinDrag] = useState(0); // è‡ªæ—‹æ‹–æ›³å¼ºåº¦ï¼ˆæƒ¯æ€§ç³»æ‹–æ›³ï¼‰
          
          // è§†å›¾é€‰é¡¹
          const [viewMode, setViewMode] = useState('cm');
          const [showSunTrail, setShowSunTrail] = useState(true);
          const [viewScale, setViewScale] = useState(45);
          
          // æ¨¡æ‹Ÿæ§åˆ¶
          const [speed, setSpeed] = useState(10);
          const [isRunning, setIsRunning] = useState(false);
          const [simTime, setSimTime] = useState(0);
          
          // ç”»å¸ƒå°ºå¯¸
          const [canvasSize, setCanvasSize] = useState({ width: window.innerWidth, height: window.innerHeight });
          
          // å¤šè¡Œæ˜Ÿé…ç½®
          const [planets, setPlanets] = useState([
            { id: 1, initR: 4.0, initVRatio: 0.97, initAngle: 90, initPhase: 0, color: PLANET_COLORS[0] },
            { id: 2, initR: 3.0, initVRatio: 1.02, initAngle: 90, initPhase: 120, color: PLANET_COLORS[1] },
            { id: 3, initR: 2.2, initVRatio: 1.03, initAngle: 90, initPhase: 240, color: PLANET_COLORS[2] },
          ]);
          
          // è¿è¡Œæ—¶çŠ¶æ€
          const [sunState, setSunState] = useState({ pos: {x:0,y:0}, vel: {x:0,y:0}, trail: [] });
          const [planetStates, setPlanetStates] = useState([]);
          const [centerOfMass, setCenterOfMass] = useState({ x: 0, y: 0 });
          const [selectedPlanet, setSelectedPlanet] = useState(1);
          
          const animationRef = useRef(null);
          const physicsState = useRef({ sun: null, planets: [], time: 0 });
          const nextPlanetId = useRef(4);

          // çª—å£å¤§å°ç›‘å¬
          useEffect(() => {
            const handleResize = () => {
              setCanvasSize({ width: window.innerWidth, height: window.innerHeight });
            };
            window.addEventListener('resize', handleResize);
            return () => window.removeEventListener('resize', handleResize);
          }, []);

          // é¼ æ ‡æ»šè½®ç¼©æ”¾
          useEffect(() => {
            const handleWheel = (e) => {
              e.preventDefault();
              const delta = e.deltaY > 0 ? 0.9 : 1.1;
              setViewScale(prev => Math.max(5, Math.min(200, prev * delta)));
            };
            window.addEventListener('wheel', handleWheel, { passive: false });
            return () => window.removeEventListener('wheel', handleWheel);
          }, []);

          // è®¡ç®—åœ†è½¨é“é€Ÿåº¦
          const getCircularVelocity = useCallback((r, gm, lam, power = gravityPower) => {
            let v2;
            if (power >= 999) {
              v2 = -lam * r * r;
            } else if (power === -1) {
              v2 = gm * r * r - lam * r * r;
            } else if (power === 0) {
              v2 = gm * r - lam * r * r;
            } else {
              v2 = gm / Math.pow(r, power - 1) - lam * r * r;
            }
            return v2 > 0 ? Math.sqrt(v2) : 0;
          }, [gravityPower]);

          const getMaxRadius = useCallback((gm, lam, power = gravityPower) => {
            if (lam <= 0) return Infinity;
            if (power >= 999) return 0;
            if (power === -1) return Infinity;
            if (power === 0) return gm / lam;
            return Math.pow(gm / lam, 1 / (power + 1));
          }, [gravityPower]);
          
          const getGravityName = (power) => {
            if (power >= 999) return 'æ— å¼•åŠ›';
            switch(power) {
              case -1: return 'è°æŒ¯å­ (âˆr)';
              case 0: return 'æ’å®šåŠ›';
              case 1: return '2D (âˆ1/r)';
              case 2: return '3D (âˆ1/rÂ²)';
              case 3: return '4D (âˆ1/rÂ³)';
              default: return `${power+1}D (âˆ1/r^${power})`;
            }
          };

          const computeCenterOfMass = useCallback((sun, planets, sunM, planetM) => {
            let totalMass = sunM;
            let cmX = sun.pos.x * sunM;
            let cmY = sun.pos.y * sunM;
            planets.forEach(p => {
              if (p.active) {
                totalMass += planetM;
                cmX += p.pos.x * planetM;
                cmY += p.pos.y * planetM;
              }
            });
            return { x: cmX / totalMass, y: cmY / totalMass };
          }, []);

          // åˆå§‹åŒ–ç³»ç»Ÿ
          const resetSimulation = useCallback(() => {
            const planetInitStates = planets.map(p => {
              const r0 = p.initR;
              const vCirc = getCircularVelocity(r0, sunMass, lambda);
              const v0 = vCirc > 0 ? p.initVRatio * vCirc : 0.5;
              const velAngleRad = (p.initAngle - 90) * Math.PI / 180;
              const phaseRad = (p.initPhase || 0) * Math.PI / 180;
              const posX = r0 * Math.cos(phaseRad);
              const posY = r0 * Math.sin(phaseRad);
              const baseVx = v0 * Math.sin(velAngleRad);
              const baseVy = v0 * Math.cos(velAngleRad);
              const velX = baseVx * Math.cos(phaseRad) - baseVy * Math.sin(phaseRad);
              const velY = baseVx * Math.sin(phaseRad) + baseVy * Math.cos(phaseRad);
              return {
                id: p.id, pos: { x: posX, y: posY }, vel: { x: velX, y: velY },
                trail: [{ x: posX, y: posY }], color: p.color, active: true
              };
            });
            
            let totalPx = 0, totalPy = 0;
            planetInitStates.forEach(p => {
              totalPx += planetMass * p.vel.x;
              totalPy += planetMass * p.vel.y;
            });
            const sunVel = { x: -totalPx / sunMass, y: -totalPy / sunMass };
            
            let cmX = 0, cmY = 0, totalMass = sunMass;
            planetInitStates.forEach(p => {
              cmX += planetMass * p.pos.x;
              cmY += planetMass * p.pos.y;
              totalMass += planetMass;
            });
            cmX /= totalMass; cmY /= totalMass;
            
            const sunPos = { x: -cmX, y: -cmY };
            planetInitStates.forEach(p => {
              p.pos.x -= cmX; p.pos.y -= cmY;
              p.trail = [{ x: p.pos.x, y: p.pos.y }];
            });
            
            physicsState.current = {
              sun: { pos: { ...sunPos }, vel: { ...sunVel }, active: true },
              planets: planetInitStates.map(s => ({ id: s.id, pos: { ...s.pos }, vel: { ...s.vel }, active: true })),
              time: 0
            };
            
            setSunState({ pos: { ...sunPos }, vel: { ...sunVel }, trail: [{ ...sunPos }] });
            setPlanetStates(planetInitStates);
            setCenterOfMass({ x: 0, y: 0 });
            setSimTime(0);
          }, [planets, sunMass, planetMass, lambda, getCircularVelocity]);

          useEffect(() => { resetSimulation(); }, []);

          const handleParamChangeEnd = useCallback(() => {
            if (!isRunning) resetSimulation();
          }, [isRunning, resetSimulation]);

          // è½¯åŒ–å¼•åŠ›
          const softenedGravity = useCallback((dx, dy, mass, eps, power) => {
            if (power >= 999) return { ax: 0, ay: 0 };
            const r2 = dx * dx + dy * dy;
            const softR2 = r2 + eps * eps;
            const r = Math.sqrt(softR2);
            let factor;
            if (power === -1) {
              factor = mass / r;
            } else if (power === 0) {
              factor = mass / softR2 * r;
            } else {
              factor = mass / Math.pow(softR2, (power + 1) / 2);
            }
            return { ax: factor * dx, ay: factor * dy };
          }, []);
          
          const physicsStep = useCallback((dt) => {
            const state = physicsState.current;
            const { sun, planets: pList } = state;
            const activePlanets = pList.filter(p => p.active);
            
            let totalMass = sunMass, cmX = sun.pos.x * sunMass, cmY = sun.pos.y * sunMass;
            activePlanets.forEach(p => {
              totalMass += planetMass;
              cmX += p.pos.x * planetMass;
              cmY += p.pos.y * planetMass;
            });
            cmX /= totalMass; cmY /= totalMass;
            
            let sunAx = lambda * (sun.pos.x - cmX);
            let sunAy = lambda * (sun.pos.y - cmY);
            activePlanets.forEach(planet => {
              const { ax, ay } = softenedGravity(planet.pos.x - sun.pos.x, planet.pos.y - sun.pos.y, planetMass, softening, gravityPower);
              sunAx += ax; sunAy += ay;
            });
            
            const planetAccels = activePlanets.map((planet, i) => {
              let ax = lambda * (planet.pos.x - cmX);
              let ay = lambda * (planet.pos.y - cmY);
              const sunGrav = softenedGravity(sun.pos.x - planet.pos.x, sun.pos.y - planet.pos.y, sunMass, softening, gravityPower);
              ax += sunGrav.ax; ay += sunGrav.ay;
              for (let j = 0; j < activePlanets.length; j++) {
                if (i === j) continue;
                const other = activePlanets[j];
                const planetGrav = softenedGravity(other.pos.x - planet.pos.x, other.pos.y - planet.pos.y, planetMass, softening, gravityPower);
                ax += planetGrav.ax; ay += planetGrav.ay;
              }
              
              // å¼•åŠ›ç£æ•ˆåº”ï¼ˆLense-Thirringæƒ¯æ€§ç³»æ‹–æ›³ï¼‰
              // åŸºäºKillingçŸ¢é‡åœºä¸æ—¶ç©ºåº¦è§„ï¼šæ—‹è½¬è´¨é‡äº§ç”Ÿå¼•åŠ›ç£åœº B_g
              // è¿åŠ¨ç‰©ä½“å—ç±»æ´›ä¼¦å…¹åŠ›ï¼ša = 2(v Ã— Ï‰_FD)ï¼Œå…¶ä¸­ Ï‰_FD = å¸§æ‹–æ›³è§’é€Ÿåº¦åœº
              // è¡°å‡è§„å¾‹ï¼šÏ‰_FD âˆ J/r^(n+1)ï¼Œn = gravityPowerï¼ˆæ¯”å¼•åŠ›å¤šè¡°å‡1/rï¼‰
              if (spinDrag > 0 && sunSpin !== 0) {
                const dx = planet.pos.x - sun.pos.x;
                const dy = planet.pos.y - sun.pos.y;
                const r2 = dx * dx + dy * dy + softening * softening;
                
                // å¸§æ‹–æ›³è§’é€Ÿåº¦åœºï¼šÏ‰_FD âˆ J / r^(gravityPower+1)
                // Jï¼ˆè§’åŠ¨é‡ï¼‰âˆ Î©_sun Ã— M_sun
                const fdPower = gravityPower + 1; // å¸§æ‹–æ›³è¡°å‡æŒ‡æ•°
                const rn = Math.pow(r2, fdPower / 2); // r^n via (rÂ²)^(n/2)
                const omegaFrame = spinDrag * sunSpin * sunMass / rn;
                
                // å¼•åŠ›ç£åŠ›ï¼ˆç±»ç§‘é‡Œå¥¥åˆ©åŠ›ï¼‰ï¼ša = 2 Ã— Ï‰_FD Ã— v
                // åœ¨xyå¹³é¢ï¼ŒÏ‰_FDæ²¿zè½´ï¼ša = 2 * Ï‰_FD * (v_y, -v_x)
                const relVx = planet.vel.x - sun.vel.x;
                const relVy = planet.vel.y - sun.vel.y;
                
                ax += 2 * omegaFrame * relVy;
                ay += -2 * omegaFrame * relVx;
              }
              
              return { ax, ay };
            });
            
            const newSunX = sun.pos.x + sun.vel.x * dt + 0.5 * sunAx * dt * dt;
            const newSunY = sun.pos.y + sun.vel.y * dt + 0.5 * sunAy * dt * dt;
            
            const newPlanetPositions = activePlanets.map((planet, i) => ({
              x: planet.pos.x + planet.vel.x * dt + 0.5 * planetAccels[i].ax * dt * dt,
              y: planet.pos.y + planet.vel.y * dt + 0.5 * planetAccels[i].ay * dt * dt
            }));
            
            let newTotalMass = sunMass, newCmX = newSunX * sunMass, newCmY = newSunY * sunMass;
            activePlanets.forEach((_, i) => {
              newTotalMass += planetMass;
              newCmX += newPlanetPositions[i].x * planetMass;
              newCmY += newPlanetPositions[i].y * planetMass;
            });
            newCmX /= newTotalMass; newCmY /= newTotalMass;
            
            let newSunAx = lambda * (newSunX - newCmX);
            let newSunAy = lambda * (newSunY - newCmY);
            activePlanets.forEach((_, i) => {
              const grav = softenedGravity(newPlanetPositions[i].x - newSunX, newPlanetPositions[i].y - newSunY, planetMass, softening, gravityPower);
              newSunAx += grav.ax; newSunAy += grav.ay;
            });
            
            const newPlanetAccels = activePlanets.map((_, i) => {
              let ax = lambda * (newPlanetPositions[i].x - newCmX);
              let ay = lambda * (newPlanetPositions[i].y - newCmY);
              const sunGrav = softenedGravity(newSunX - newPlanetPositions[i].x, newSunY - newPlanetPositions[i].y, sunMass, softening, gravityPower);
              ax += sunGrav.ax; ay += sunGrav.ay;
              for (let j = 0; j < activePlanets.length; j++) {
                if (i === j) continue;
                const planetGrav = softenedGravity(newPlanetPositions[j].x - newPlanetPositions[i].x, newPlanetPositions[j].y - newPlanetPositions[i].y, planetMass, softening, gravityPower);
                ax += planetGrav.ax; ay += planetGrav.ay;
              }
              
              // å¼•åŠ›ç£æ•ˆåº”ï¼ˆæ–°ä½ç½®ï¼Œä½¿ç”¨ä¼°ç®—é€Ÿåº¦ï¼‰
              if (spinDrag > 0 && sunSpin !== 0) {
                const dx = newPlanetPositions[i].x - newSunX;
                const dy = newPlanetPositions[i].y - newSunY;
                const r2 = dx * dx + dy * dy + softening * softening;
                
                const fdPower = gravityPower + 1;
                const rn = Math.pow(r2, fdPower / 2);
                const omegaFrame = spinDrag * sunSpin * sunMass / rn;
                
                const relVx = activePlanets[i].vel.x - sun.vel.x;
                const relVy = activePlanets[i].vel.y - sun.vel.y;
                
                ax += 2 * omegaFrame * relVy;
                ay += -2 * omegaFrame * relVx;
              }
              
              return { ax, ay };
            });
            
            sun.vel.x += 0.5 * (sunAx + newSunAx) * dt;
            sun.vel.y += 0.5 * (sunAy + newSunAy) * dt;
            sun.pos.x = newSunX; sun.pos.y = newSunY;
            
            // æ˜Ÿé™…æ°”ä½“é˜»å°¼ï¼ˆå¯¹å¤ªé˜³ä¹Ÿæœ‰å¾®å¼±ä½œç”¨ï¼‰
            if (damping > 0) {
              const dampFactor = Math.exp(-damping * dt * 0.1); // å¤ªé˜³å—é˜»å°¼è¾ƒå°
              sun.vel.x *= dampFactor;
              sun.vel.y *= dampFactor;
            }
            
            activePlanets.forEach((planet, i) => {
              planet.vel.x += 0.5 * (planetAccels[i].ax + newPlanetAccels[i].ax) * dt;
              planet.vel.y += 0.5 * (planetAccels[i].ay + newPlanetAccels[i].ay) * dt;
              planet.pos.x = newPlanetPositions[i].x;
              planet.pos.y = newPlanetPositions[i].y;
              
              // æ˜Ÿé™…æ°”ä½“é˜»å°¼ï¼ˆè¡Œæ˜Ÿå—é˜»å°¼æ›´å¤§ï¼‰
              if (damping > 0) {
                const dampFactor = Math.exp(-damping * dt);
                planet.vel.x *= dampFactor;
                planet.vel.y *= dampFactor;
              }
            });
            
            state.time += dt;
            return true;
          }, [sunMass, planetMass, lambda, softening, gravityPower, damping, sunSpin, spinDrag, softenedGravity]);

          // åŠ¨ç”»å¾ªç¯
          useEffect(() => {
            if (!isRunning) {
              if (animationRef.current) cancelAnimationFrame(animationRef.current);
              return;
            }
            let lastFrameTime = null;
            const animate = (currentTime) => {
              const deltaTime = lastFrameTime !== null ? Math.min(currentTime - lastFrameTime, 50) : 16;
              lastFrameTime = currentTime;
              const dt = 0.0005;
              const stepsPerFrame = Math.round(speed * 10 * deltaTime / 16);
              for (let i = 0; i < Math.min(stepsPerFrame, 200); i++) physicsStep(dt);
              
              const state = physicsState.current;
              setSimTime(state.time);
              
              setSunState(prev => {
                const lastPoint = prev.trail[prev.trail.length - 1];
                let newTrail = prev.trail;
                if (!lastPoint || Math.abs(state.sun.pos.x - lastPoint.x) > 0.005 || Math.abs(state.sun.pos.y - lastPoint.y) > 0.005) {
                  newTrail = [...prev.trail, { x: state.sun.pos.x, y: state.sun.pos.y }];
                  if (newTrail.length > 20000) newTrail = newTrail.slice(-20000); // ä¸æ“¦é™¤è½¨è¿¹
                }
                return { pos: { ...state.sun.pos }, vel: { ...state.sun.vel }, trail: newTrail };
              });
              
              setPlanetStates(prev => prev.map(ps => {
                  const current = state.planets.find(p => p.id === ps.id);
                if (!current) return ps;
                  const lastPoint = ps.trail[ps.trail.length - 1];
                  let newTrail = ps.trail;
                if (!lastPoint || Math.abs(current.pos.x - lastPoint.x) > 0.02 || Math.abs(current.pos.y - lastPoint.y) > 0.02) {
                    newTrail = [...ps.trail, { x: current.pos.x, y: current.pos.y }];
                    if (newTrail.length > 30000) newTrail = newTrail.slice(-30000); // ä¸æ“¦é™¤è½¨è¿¹
                  }
                return { ...ps, pos: { ...current.pos }, vel: { ...current.vel }, trail: newTrail };
              }));
              
              setCenterOfMass(computeCenterOfMass(state.sun, state.planets, sunMass, planetMass));
                animationRef.current = requestAnimationFrame(animate);
            };
            animationRef.current = requestAnimationFrame(animate);
            return () => { if (animationRef.current) cancelAnimationFrame(animationRef.current); };
          }, [isRunning, speed, physicsStep, sunMass, planetMass, computeCenterOfMass]);

          const addPlanet = () => {
            if (planets.length >= 8) return;
            const newId = nextPlanetId.current++;
            setPlanets(prev => [...prev, {
              id: newId, initR: 0.5 + planets.length * 0.5, initVRatio: 1.0, initAngle: 90,
              initPhase: (planets.length * 60) % 360, color: PLANET_COLORS[planets.length % PLANET_COLORS.length]
            }]);
          };

          const removePlanet = (id) => {
            if (planets.length <= 1) return;
            setPlanets(prev => prev.filter(p => p.id !== id));
            if (selectedPlanet === id) setSelectedPlanet(planets[0].id);
          };

          const updatePlanet = (id, key, value) => {
            setPlanets(prev => prev.map(p => p.id === id ? { ...p, [key]: value } : p));
          };

          const getViewCenter = () => {
            if (viewMode === 'sun') return sunState.pos;
            if (viewMode === 'cm') return centerOfMass;
            return { x: 0, y: 0 };
          };

          const worldToScreen = (x, y) => {
            const center = getViewCenter();
            return {
              x: canvasSize.width / 2 + (x - center.x) * viewScale,
              y: canvasSize.height / 2 - (y - center.y) * viewScale
            };
          };

          const selectedState = planetStates.find(p => p.id === selectedPlanet);
          const rFromSun = selectedState && sunState ? Math.sqrt(
            (selectedState.pos.x - sunState.pos.x) ** 2 + (selectedState.pos.y - sunState.pos.y) ** 2
          ) : 0;

          // å‚æ•°æ»‘æ¡ç»„ä»¶
          const ParamSlider = ({ label, value, setValue, min, max, step = 0.01, onChangeEnd }) => {
            const [sliderValue, setSliderValue] = useState(value);
            const [inputText, setInputText] = useState(String(value));
            const [isSliding, setIsSliding] = useState(false);
            const [isTyping, setIsTyping] = useState(false);
            
            useEffect(() => {
              if (!isSliding) setSliderValue(value);
              if (!isTyping) setInputText(String(value));
            }, [value, isSliding, isTyping]);
            
            return (
              <div className="mb-3">
                <div className="flex justify-between items-center mb-1">
                  <label className="text-xs text-gray-300">{label}</label>
                  <input type="text" inputMode="decimal" value={inputText}
                    onChange={(e) => setInputText(e.target.value)}
                    onFocus={() => setIsTyping(true)}
                    onBlur={() => {
                      const val = parseFloat(inputText);
                      if (!isNaN(val)) {
                        const clamped = Math.max(min, Math.min(max, val));
                        setSliderValue(clamped); setInputText(String(clamped)); setValue(clamped);
                      } else setInputText(String(value));
                      setIsTyping(false);
                      if (onChangeEnd) onChangeEnd();
                    }}
                    onKeyDown={(e) => { if (e.key === 'Enter') e.target.blur(); }}
                    className="param-input"
                  />
                </div>
                <input type="range" min={min} max={max} step={step} value={sliderValue}
                  onChange={(e) => { setSliderValue(parseFloat(e.target.value)); setInputText(e.target.value); }}
                  onMouseDown={() => setIsSliding(true)}
                  onTouchStart={() => setIsSliding(true)}
                  onMouseUp={() => { setIsSliding(false); setValue(sliderValue); if (onChangeEnd) onChangeEnd(); }}
                  onTouchEnd={() => { setIsSliding(false); setValue(sliderValue); if (onChangeEnd) onChangeEnd(); }}
                  className="w-full"
                />
              </div>
            );
          };

          return (
            <div className="relative w-full h-full bg-black text-white">
              {/* å…¨å±ç”»å¸ƒ */}
              <svg width={canvasSize.width} height={canvasSize.height} className="absolute inset-0">
                        {/* èƒŒæ™¯ç½‘æ ¼ */}
                {Array.from({ length: 20 }, (_, i) => i + 1).map(r => (
                  <circle key={r} cx={canvasSize.width/2} cy={canvasSize.height/2}
                    r={r * viewScale} fill="none" stroke="#1a1a2e" strokeWidth="1" />
                ))}
                <line x1={canvasSize.width/2} y1="0" x2={canvasSize.width/2} y2={canvasSize.height} stroke="#1a1a2e" />
                <line x1="0" y1={canvasSize.height/2} x2={canvasSize.width} y2={canvasSize.height/2} stroke="#1a1a2e" />
                        
                        {/* è´¨å¿ƒæ ‡è®° */}
                        {viewMode !== 'cm' && (() => {
                  const cm = worldToScreen(centerOfMass.x, centerOfMass.y);
                          return (
                            <g>
                      <line x1={cm.x - 12} y1={cm.y} x2={cm.x + 12} y2={cm.y} stroke="#a855f7" strokeWidth="2" />
                      <line x1={cm.x} y1={cm.y - 12} x2={cm.x} y2={cm.y + 12} stroke="#a855f7" strokeWidth="2" />
                            </g>
                          );
                        })()}
                        
                        {/* å¤ªé˜³è½¨è¿¹ */}
                        {showSunTrail && sunState.trail.length > 1 && (
                  <path d={sunState.trail.map((p, i) => {
                    const s = worldToScreen(p.x, p.y);
                    return `${i === 0 ? 'M' : 'L'} ${s.x} ${s.y}`;
                  }).join(' ')} fill="none" stroke="#ffdd44" strokeWidth="1.5" opacity="0.4" />
                        )}
                        
                        {/* è¡Œæ˜Ÿè½¨è¿¹ */}
                {planetStates.map(planet => planet.trail.length > 1 && (
                  <path key={`trail-${planet.id}`}
                              d={planet.trail.map((p, i) => {
                      const s = worldToScreen(p.x, p.y);
                      return `${i === 0 ? 'M' : 'L'} ${s.x} ${s.y}`;
                              }).join(' ')}
                    fill="none" stroke={planet.color}
                    // strokeWidth={planet.id === selectedPlanet ? "2.5" : "1.5"}
                    //           opacity={planet.id === selectedPlanet ? "0.9" : "0.5"}
                              strokeWidth={1.5}
                              opacity={0.5}
                            />
                        ))}
                        
                        {/* å¤ªé˜³ */}
                        {(() => {
                  const s = worldToScreen(sunState.pos.x, sunState.pos.y);
                          return (
                            <g>
                      <circle cx={s.x} cy={s.y} r="18" fill="#ffdd44" />
                      <circle cx={s.x} cy={s.y} r="26" fill="none" stroke="#ffdd44" strokeWidth="2" opacity="0.3" />
                            </g>
                          );
                        })()}
                        
                        {/* è¡Œæ˜Ÿ */}
                        {planetStates.map(planet => {
                  const s = worldToScreen(planet.pos.x, planet.pos.y);
                          const isSelected = planet.id === selectedPlanet;
                          return (
                            <g key={`planet-${planet.id}`} onClick={() => setSelectedPlanet(planet.id)} style={{ cursor: 'pointer' }}>
                      <circle cx={s.x} cy={s.y} r={isSelected ? 12 : 8} fill={planet.color}
                        stroke={isSelected ? "#fff" : "none"} strokeWidth="2" />
                              {isSelected && (
                                <>
                          <line x1={s.x} y1={s.y} x2={s.x + planet.vel.x * 40} y2={s.y - planet.vel.y * 40}
                            stroke="#ff8844" strokeWidth="3" />
                          <circle cx={s.x + planet.vel.x * 40} cy={s.y - planet.vel.y * 40} r="4" fill="#ff8844" />
                                </>
                              )}
                            </g>
                          );
                        })}
                      </svg>

              {/* å·¦ä¸Šï¼šå®‡å®™å‚æ•° */}
              <div className="absolute top-4 left-4 w-64">
                <Panel title="å®‡å®™å‚æ•°" icon="ğŸŒŒ" defaultOpen={true}>
                  <ParamSlider label="Î› (å®‡å®™å­¦å¸¸æ•°)" value={lambda} setValue={setLambda}
                    min={-0.1} max={0.1} step={0.001} onChangeEnd={handleParamChangeEnd} />
                  <ParamSlider label="å¤ªé˜³è´¨é‡ Mâ˜‰" value={sunMass} setValue={setSunMass}
                    min={0.1} max={5} step={0.01} onChangeEnd={handleParamChangeEnd} />
                  <ParamSlider label="è¡Œæ˜Ÿè´¨é‡ (Ã—Mâ˜‰)" value={planetMass} setValue={setPlanetMass}
                    min={0} max={1} step={0.001} onChangeEnd={handleParamChangeEnd} />
<ParamSlider label="è½¯åŒ–é•¿åº¦ Îµ" value={softening} setValue={setSoftening}
                    min={0.01} max={2} step={0.01} onChangeEnd={handleParamChangeEnd} />
                  <ParamSlider label="æ°”ä½“é˜»å°¼ Î³" value={damping} setValue={setDamping}
                    min={0} max={0.5} step={0.001} onChangeEnd={handleParamChangeEnd} />
                  {damping > 0 && (
                    <div className="text-xs text-gray-500 -mt-2 mb-2">
                      é˜»å°¼æ—¶é—´å°ºåº¦: ~{(1/damping).toFixed(1)}
                    </div>
                  )}
                  
                  <ParamSlider label="æ’æ˜Ÿè‡ªæ—‹ Î©" value={sunSpin} setValue={setSunSpin}
                    min={-2} max={2} step={0.01} onChangeEnd={handleParamChangeEnd} />
                  <ParamSlider label="è‡ªæ—‹æ‹–æ›³ Îº" value={spinDrag} setValue={setSpinDrag}
                    min={0} max={0.1} step={0.001} onChangeEnd={handleParamChangeEnd} />
                  {spinDrag > 0 && sunSpin !== 0 && (
                    <div className="text-xs text-gray-500 -mt-2 mb-2">
                      æƒ¯æ€§ç³»æ‹–æ›³: {sunSpin > 0 ? 'é€†æ—¶é’ˆ' : 'é¡ºæ—¶é’ˆ'} åŠ é€Ÿè¡Œæ˜Ÿ
                    </div>
                  )}

                  <div className="mb-2">
                    <label className="text-xs text-gray-300 block mb-1">å¼•åŠ›å®šå¾‹</label>
                    <div className="flex gap-1">
                      {[-1, 0, 1, 2, 3, 999].map(power => (
                        <button key={power}
                          onClick={() => { setGravityPower(power); handleParamChangeEnd(); }}
                          className={`flex-1 py-1 rounded text-xs transition ${
                            gravityPower === power ? 'bg-cyan-600' : 'bg-gray-700 hover:bg-gray-600'
                          }`}>
                          {power === -1 ? 'âˆr' : power === 0 ? 'å®š' : power === 1 ? '1/r' : power === 2 ? '1/rÂ²' : power === 3 ? '1/rÂ³' : 'æ— '}
                      </button>
                      ))}
                    </div>
                  </div>
                  
                  <div className="text-xs p-2 bg-gray-800 rounded">
                    <div>å¼•åŠ›: <span className="text-cyan-400">{getGravityName(gravityPower)}</span></div>
                    <div>Î›: <span className={lambda < 0 ? "text-pink-400" : lambda > 0 ? "text-yellow-400" : "text-gray-400"}>
                      {lambda < 0 ? 'AdS' : lambda > 0 ? 'dS' : 'å¹³å¦'}
                    </span></div>
                    </div>
                </Panel>
                </div>
                
              {/* å·¦ä¸‹ï¼šæ¨¡æ‹Ÿæ§åˆ¶ */}
              <div className="absolute bottom-4 left-4 w-64">
                <Panel title="æ¨¡æ‹Ÿæ§åˆ¶" icon="âš™ï¸" defaultOpen={true}>
                  <ParamSlider label="æ¨¡æ‹Ÿé€Ÿåº¦" value={speed} setValue={setSpeed} min={0} max={20} step={0.1} />
                  <ParamSlider label="è§†å›¾ç¼©æ”¾" value={viewScale} setValue={setViewScale} min={5} max={200} step={1} />
                  
                  <div className="text-xs text-gray-400 mb-2">
                    æ—¶é—´: <span className="text-white font-mono">{simTime.toFixed(2)}</span>
                </div>
                
                  <div className="flex gap-2 mb-2">
                    <button onClick={() => setIsRunning(!isRunning)}
                      className={`flex-1 py-2 rounded text-sm font-semibold ${isRunning ? 'bg-yellow-600' : 'bg-green-600'}`}>
                      {isRunning ? 'â¸ æš‚åœ' : 'â–¶ è¿è¡Œ'}
                      </button>
                    <button onClick={() => { setIsRunning(false); setTimeout(resetSimulation, 50); }}
                      className="flex-1 py-2 rounded text-sm font-semibold bg-blue-600">ğŸ”„ é‡ç½®</button>
                    </div>
                    
                  <div className="flex gap-1 mb-2">
                    {[{ mode: 'cm', label: 'è´¨å¿ƒ' }, { mode: 'sun', label: 'å¤ªé˜³' }, { mode: 'inertial', label: 'æƒ¯æ€§' }].map(({ mode, label }) => (
                      <button key={mode} onClick={() => setViewMode(mode)}
                        className={`flex-1 py-1 rounded text-xs ${viewMode === mode ? 'bg-purple-600' : 'bg-gray-700'}`}>{label}</button>
                    ))}
                  </div>
                  
                  <label className="flex items-center gap-2 text-xs cursor-pointer">
                    <input type="checkbox" checked={showSunTrail} onChange={(e) => setShowSunTrail(e.target.checked)} />
                    æ˜¾ç¤ºå¤ªé˜³è½¨è¿¹
                  </label>
                </Panel>
              </div>

              {/* å³ä¸Šï¼šè¡Œæ˜Ÿåˆ—è¡¨ */}
              <div className="absolute top-4 right-4 w-56">
                <Panel title="è¡Œæ˜Ÿåˆ—è¡¨" icon="ğŸª" defaultOpen={true}>
                          <div className="flex justify-between items-center mb-2">
                    <span className="text-xs text-gray-400">{planets.length}/8 è¡Œæ˜Ÿ</span>
                    <button onClick={addPlanet} disabled={planets.length >= 8}
                      className={`px-2 py-1 rounded text-xs ${planets.length >= 8 ? 'bg-gray-600' : 'bg-green-600'}`}>+ æ·»åŠ </button>
                  </div>
                  
                  <div className="space-y-1 max-h-60 overflow-y-auto">
                    {planets.map(planet => (
                      <div key={planet.id}
                        className={`p-2 rounded cursor-pointer ${selectedPlanet === planet.id ? 'bg-gray-700 ring-1 ring-cyan-500' : 'hover:bg-gray-800'}`}
                        onClick={() => setSelectedPlanet(planet.id)}>
                        <div className="flex justify-between items-center">
                            <div className="flex items-center gap-2">
                            <span className="w-3 h-3 rounded-full" style={{ background: planet.color }}></span>
                            <span className="text-xs">#{planet.id}</span>
                            </div>
                            {planets.length > 1 && (
                            <button onClick={(e) => { e.stopPropagation(); removePlanet(planet.id); }}
                              className="text-red-400 text-xs px-1">âœ•</button>
                            )}
                          </div>
                          
                          {selectedPlanet === planet.id && (
                          <div className="mt-2 space-y-2">
                            <ParamSlider label="è·ç¦» râ‚€" value={planet.initR}
                                setValue={(v) => updatePlanet(planet.id, 'initR', v)}
                              min={0.2} max={5} step={0.05} onChangeEnd={handleParamChangeEnd} />
                            <ParamSlider label="é€Ÿåº¦æ¯”" value={planet.initVRatio}
                                setValue={(v) => updatePlanet(planet.id, 'initVRatio', v)}
                              min={0.1} max={2} step={0.05} onChangeEnd={handleParamChangeEnd} />
                            <ParamSlider label="é€Ÿåº¦æ–¹å‘Â°" value={planet.initAngle}
                                setValue={(v) => updatePlanet(planet.id, 'initAngle', v)}
                              min={0} max={180} step={1} onChangeEnd={handleParamChangeEnd} />
                            <div className="text-xs text-gray-500 -mt-1 mb-1">
                              {planet.initAngle === 90 ? 'åœ†è½¨é“' : planet.initAngle < 90 ? 'å‘å†…èºæ—‹' : 'å‘å¤–èºæ—‹'}
                            </div>
                            <ParamSlider label="ç›¸ä½Â°" value={planet.initPhase || 0}
                                setValue={(v) => updatePlanet(planet.id, 'initPhase', v)}
                              min={0} max={360} step={5} onChangeEnd={handleParamChangeEnd} />
                            <div className="text-xs text-gray-500">åˆ°å¤ªé˜³: {rFromSun.toFixed(3)}</div>
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                </Panel>
                  </div>
                  
              {/* å³ä¸‹ï¼šé¢„è®¾ */}
              <div className="absolute bottom-4 right-4 w-56">
                <Panel title="é¢„è®¾åœºæ™¯" icon="â­" defaultOpen={false}>
                  <div className="space-y-1">
                    {[
                      { name: 'é»˜è®¤é…ç½®', fn: () => { setLambda(-0.01); setSunMass(1.0); setPlanetMass(0.1); setGravityPower(3); } },
                      { name: 'AdSå¤ªé˜³ç³»', fn: () => { setLambda(-0.001); setPlanetMass(0.001); } },
                      { name: 'åŒæ˜Ÿå¯¹ç§°', fn: () => { setLambda(-0.005); setPlanetMass(0.02); setPlanets([
                        { id: 1, initR: 1.2, initVRatio: 1.0, initAngle: 90, initPhase: 0, color: PLANET_COLORS[0] },
                        { id: 2, initR: 1.2, initVRatio: 1.0, initAngle: 90, initPhase: 180, color: PLANET_COLORS[1] },
                      ]); } },
                      { name: 'ä¸‰ä½“é—®é¢˜', fn: () => { setLambda(-0.003); setPlanetMass(0.015); setPlanets([
                        { id: 1, initR: 1.5, initVRatio: 1.0, initAngle: 90, initPhase: 0, color: PLANET_COLORS[0] },
                        { id: 2, initR: 1.5, initVRatio: 1.0, initAngle: 90, initPhase: 120, color: PLANET_COLORS[1] },
                        { id: 3, initR: 1.5, initVRatio: 1.0, initAngle: 90, initPhase: 240, color: PLANET_COLORS[2] },
                      ]); } },
                      { name: 'ç«ç‘°è½¨é“', fn: () => { setLambda(-0.01); setPlanetMass(0.001); setPlanets([
                        { id: 1, initR: 2.0, initVRatio: 1.3, initAngle: 90, initPhase: 0, color: PLANET_COLORS[0] },
                      ]); } },
                    ].map(({ name, fn }) => (
                      <button key={name} onClick={() => { fn(); setIsRunning(false); setTimeout(resetSimulation, 50); }}
                        className="w-full py-1.5 px-2 bg-gray-700 hover:bg-gray-600 rounded text-xs text-left">{name}</button>
                    ))}
                  </div>
                </Panel>
              </div>
              
              {/* ä¸­ä¸‹ï¼šçŠ¶æ€ä¿¡æ¯ */}
              <div className="absolute bottom-4 left-1/2 -translate-x-1/2 text-xs text-gray-500 text-center">
                <div>æ»šè½®ç¼©æ”¾ Â· ç‚¹å‡»è¡Œæ˜Ÿé€‰ä¸­ Â· {viewMode === 'cm' ? 'è´¨å¿ƒ' : viewMode === 'sun' ? 'å¤ªé˜³' : 'æƒ¯æ€§ç³»'}å‚è€ƒç³»</div>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OrbitalSimulator4D />);
    </script>
</body>
</html>
